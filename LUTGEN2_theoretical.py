# Modified SRT LUT Generation Script with Theoretical Boundaries
# Based on the original LUTGEN2.py

def generate_srt_lut_theoretical(divisor_bits=4, pr_bits=5, output_file="srt_lut_theoretical.txt"):
    """
    Generate an SRT Radix-4 division lookup table with theoretical boundaries and write to a file.
    
    Parameters:
    - divisor_bits: number of bits for divisor (after implicit leading 1)
    - pr_bits: number of bits for partial remainder (including sign bit)
    - output_file: file to write the LUT data
    """
    # Total entries in the LUT
    total_entries = 2**(divisor_bits + pr_bits)
    lut = [0] * total_entries
    
    # For each possible divisor value
    # We assume normalized divisor has the form 0.1xxx... (where xxx are the bits we use)
    for d_idx in range(2**divisor_bits):
        # Convert to actual normalized divisor value
        # The divisor is 0.5 (0.1 in binary) plus the fractional value of the divisor bits
        d = 0.5 + (d_idx / (2**(divisor_bits+1)))
        
        # For each possible partial remainder value (5 bits with sign)
        for pr_idx in range(2**pr_bits):
            # Convert to actual partial remainder value
            # MSB is sign bit, rest are magnitude bits
            # Interpret as a fixed-point value in [-1, 1)
            if pr_idx < 2**(pr_bits-1):  # Positive value
                pr = pr_idx / (2**(pr_bits-1))
            else:  # Negative value
                pr = (pr_idx - 2**pr_bits) / (2**(pr_bits-1))
            
            # Apply theoretical SRT selection rules
            q = 0
            
            # These are the standard theoretical boundaries for SRT radix-4
            if pr >= (1.3333333333333333) * d:
                q = 2
            elif pr >= (0.3333333333333333) * d:
                q = 1
            elif pr > -(0.3333333333333333) * d:
                q = 0
            elif pr > -(1.3333333333333333) * d:
                q = -1
            else:
                q = -2
            
            # Calculate address: concatenate divisor and partial remainder bits
            # Format: [divisor_bits][pr_bits]
            address = (d_idx << pr_bits) | pr_idx
            
            # Store in lookup table at the calculated address
            lut[address] = q
    
    # Write to output file
    with open(output_file, "w") as f:
        # Write header
        f.write(f"// SRT Radix-4 Division LUT with Theoretical Boundaries\n")
        f.write(f"// 4 divisor bits (after implicit leading 1), 5 partial remainder bits\n")
        f.write(f"// Address format: [divisor_bits][pr_bits]\n")
        f.write(f"// Quotient digits: {-2, -1, 0, 1, 2}\n")
        f.write(f"// Boundaries: q2=1.3333333333333333d, q1=0.3333333333333333d, q0=0.3333333333333333d, qn1=1.3333333333333333d\n\n")
        
        # Write entries in format suitable for Verilog
        for i in range(total_entries):
            # Format as 3 bits (for -2 to 2, using 2's complement)
            # -2 = 110, -1 = 111, 0 = 000, 1 = 001, 2 = 010
            q_val = lut[i]
            if q_val < 0:
                q_fmt = 8 + q_val  # 2's complement in 3 bits
            else:
                q_fmt = q_val
                
            # Write in format: address: value
            d_part = i >> pr_bits
            pr_part = i & ((1 << pr_bits) - 1)
            actual_d = 0.5 + (d_part / (2**(divisor_bits+1)))
            
            f.write(f"{i:0{(divisor_bits + pr_bits)//4 + 1}X}: {q_fmt:03b} // d=0.1{d_part:0{divisor_bits}b} ({actual_d:.6f}), pr={pr_part:0{pr_bits}b}, q={q_val}\n")
    
    # Also create a Verilog module file
    with open(output_file.replace(".txt", ".v"), "w") as f:
        f.write(f"""// SRT Radix-4 Division Quotient Selection LUT with Theoretical Boundaries
// 4 divisor bits (after implicit leading 1), 5 partial remainder bits
// Boundaries: q2=1.3333333333333333d, q1=0.3333333333333333d, q0=0.3333333333333333d, qn1=1.3333333333333333d
// Generated by script

module srt_quotient_selection_lut_theoretical (
    input wire [3:0] d_bits,  // Divisor bits after implicit leading 1
    input wire [4:0] pr_bits,      // Partial remainder bits
    output reg [2:0] q_out                   // Quotient digit in 3-bit 2's complement
);

    wire [8:0] address;
    assign address = {{d_bits, pr_bits}};
    
    always @(*) begin
        case(address)
""")
        
        # Write case statements for each entry
        for i in range(total_entries):
            q_val = lut[i]
            if q_val < 0:
                q_fmt = 8 + q_val  # 2's complement in 3 bits
            else:
                q_fmt = q_val
                
            f.write(f"            {divisor_bits+pr_bits}'h{i:0{(divisor_bits + pr_bits)//4 + 1}X}: q_out = 3'b{q_fmt:03b}; // {q_val}\n")
        
        f.write(f"""            default: q_out = 3'b000;
        endcase
    end
endmodule
""")

    print(f"LUT generated with {total_entries} entries using theoretical boundaries.")
    print(f"Text file saved as: {output_file}")
    print(f"Verilog module saved as: {output_file.replace('.txt', '.v')}")
    
    # Also create a hex file (for $readmemh)
    with open(output_file.replace(".txt", ".hex"), "w") as f:
        for i in range(total_entries):
            q_val = lut[i]
            if q_val < 0:
                q_fmt = 8 + q_val  # 2's complement in 3 bits
            else:
                q_fmt = q_val
            f.write(f"{q_fmt:X}\n")
    
    print(f"Hex file for $readmemh saved as: {output_file.replace('.txt', '.hex')}")

# Generate the LUT with 4 divisor bits and 5 partial remainder bits using theoretical boundaries
generate_srt_lut_theoretical(4, 5)
